关键点思考和经验认识
JVM
JVM是基于JVM字节码构成的应用程序进程的容器，提供了JVM字节码运行的资源环境，不限于对Java语言的支持，Scala，Kotlin，Groovy等其他符合JVM规范的语言编译出的JVM字节码都可以运行于JVM之上，甚至Python语言也有基于JVM的解释器，可是说是整个Java生态的基座，为应用程序提供了跨操作系统平台的快速“移植”能力，做到所谓“一次编译，到处执行”，作为应用程序容器，JVM本身可以基于大量参数进行灵活配置，调整其使用的内存布局方式和GC算法等参数，为不同的应用定制最合适的运行环境

JVM最大特点是将内存管理接管，动态分配的分配由应用进程触发，但是垃圾内存的回收是由JVM接管进行，将上游应用程序从C++这类语言中繁琐的堆内存管理中解放出来，能够让应用程序本身的运行逻辑更多关注在业务上，但上游应用仍然需要根据应用自身的特性和运行的物理环境合适配置好GC相关的参数，同时在业务代码中基于对GC底层原理的理解，做好对象生成的管理，避免频繁的GC带来的性能损耗，GC并不能接管所有内存相关的管理工作，需要应用程序的逻辑合理地和GC配合，才能让JVM进行高效的内存管理

JVM第二大特点是提供了类元信息存储和解析的功能，是Java语言中注解和反射特性实现的前提，是相对C++这类语言所没有的重大特性，能够让上游代码实现更加灵活优雅，这本身都是得益于JVM底层结构优秀的设计

JVM本身是平台，同时也是规范，定义了字节码标准，应用程序进程结构，内存布局等，规范了应用进程的组成结构和编译器的实现方式，对于开发人员而言要开发出高效稳定运行的程序，需要理解透彻设么样的代码会编译出什么样的字节码，什么样的对象生成和销毁方式会给GC带来负担，在业务层面避掉低效率的编码方式，所以对于一个合格的开发者而言，必须理解清楚JVM运行的原理，编写代码时候就应该考虑清楚不同的编码方式对JVM底层运行带来的影响，这是编写高效代码的必备技能，同时也是及早发现问题和瓶颈的手段，所谓知其然而须知其所以然，不仅仅是针对Java语言，对开发人员而言，对自己在工程中使用的任何语言，其底层运行的核心原理都应该熟练掌握，这样能做到开发过程中心中有底，避免在开发时候引入会导致底层出问题的代码，此类代码在实际工程中大概率会引发疑难问题，通过对底层平台透彻的理解，可以让开发人员在编码阶段就将大部分这类问题消灭掉，不论站在开发者本身的角度还是站在工程管理的角度去看，对JVM这类底层技术原理有透彻理解，都是有巨大益处的。

NIO
NIO是基于多路复用原理对传统BIO的一种优化，针对磁盘或者网络Socket的读写IO操作有多种模型，最简单的模型是传统的阻塞IO，用户线程调用API发起读写后会阻塞住直到有数据可读或可写之后才能携带数据返回，在此期间线程完全阻塞无法进行任何业务处理，效率极其低下，每访问一个数据源，都必须要新启动一个线程，每个线程只能处理自己读写的数据源；改进版本为非阻塞IO，应用线程发起读写之后，不会阻塞等待数据准备就绪，而是立刻从调用的API返回，返回之后可以处理其他业务逻辑，但是需要有任务不断轮询数据源的数据是否准备好，可以一个线程处理多个数据源的读写，但是缺陷仍然比较明显，轮询的频率难以控制，轮询过快会大量消耗CPU，轮询过慢会造成数据读写速度下降；NIO模型在非阻塞IO上进行了改进，用事件驱动的方式对IO读写进行了优化，利用操作系统底层提供的select，epoll等机制实现一个线程监控多个IO数据源的可读可写状态，当有可读可写事件发生时候，通知对应的业务逻辑进行处理，对于简单的业务可以直接用监控数据源的线程执行，对于比较复杂的业务可以借助线程池获取空闲线程执行对应的读写业务逻辑，Linux内核中的epoll机制为NIO提供了很好的支持，该内核特性通过回调通知方式高效实现了可读可写事件的通知，且对监控的文件描述符数量没有限制，能够支撑10万连接的同时监控；异步的AIO相对NIO而言更进一步，NIO是在数据可读可写时候通知业务逻辑，而业务逻辑依然要调用系统调用从内核协议栈中拉取数据或者是写入数据，此期间业务线程依然是阻塞的，AIO基于操作系统底层的SIGIO机制，在数据完全从内核态搬移到用户态(读取场景)时候或者数据完全写入内核缓冲区(写数据场景)之后才会通知业务线程进行处理，避免了用户线程在和操作系统内核交互时候的阻塞，对于业务的线程的阻塞时间更短，理论上是效率最高的一种IO模型；实际开发项目中，NIO模型使用相对较多，开发过程中难免会和IO读写打交道，作为开发人员，应该首先从模型层面将各种IO读写方式理解透彻，明确其优缺点，因地制宜，根据实际的应用场景选择合适的IO模型。

并发编程
并发处理是复杂业务逻辑中基本上随处可见的多任务工作模式，在当前的软件工业中，不论是传统软件领域还是互联网应用领域，基本已经看不到完全的单任务工作模式，当下软件业务逻辑的复杂度必然导致功能逻辑需要多任务协同完成，如何高效进行多任务的协同工作，就是并发编程要解决的核心问题，并发的概念不仅仅局限于多线程，任何多任务协同完成业务逻辑的场景都属于并发编程场景

业务中最常见的并发场景是同一进程中的多线程并发问题，要解决的核心问题主要有两个：

多线程同时访问一个非线程安全资源（此处的资源不单纯指代数据资源，包括可执行代码临界区也可认为是资源），如何保证资源的访问安全不出异常，且最终结果是正确的

多线程协同工作，如何高效进行交互和同步，让整体业务逻辑执行高效

问题1有很多种解决方式，不论是synchronize块，加锁，读写锁分离，信号量等手段阻塞线程，还是CountdownLatch，CyclicBarrier等等不同方法保持线程同步，本质上都是在通过不同的方式构造临界区，而能够同时处于临界区内部的线程数量根据不同的业务逻辑有所不同，常见的情况是临界区同一时刻只能有一个线程进入以保证不会发生多个任务同时访问一个资源带来的冲突，由于解决冲突的需要，必然会在需要在多个线程并发进入临界区之前，先阻塞住一部分线程，等待已经进入临界区的线程释放资源后再进入临界区工作，天然地需要各种机制来实现这种“拿资源，释放资源”的操作，Java Concurrent包中提供了各种控制线程同步的工具类和支持原子操作的数据结构实现，应用场景和实现原理都有所不同，但是本质做的就是一件事 ------ “通过构造临界区控制多任务的同步”，把握住这个核心原理，针对不同的应用场景选用合适的方式控制并发访问的流程，就是并发编程的核心。由于问题1的解决手段本质核心是构造临界区，所以天然会有问题2，临界区的粒度和临界区的构造方式需要在保证业务正确性前提下，根据业务场景做合适的选择，否则会导致多任务同步开销过大，影响业务逻辑，作为合格的开发人员，需要理解透彻理解乐观锁，悲观锁，偏向锁，CAS等加锁机制的原理，掌控好临界区的粒度，实际编码时候就要想清楚当前使用的同步控制机制会带来什么样的开销和损耗，时刻注意资源有没有多任务访问的场景，在业务的逻辑的高效性和安全性上要进行双重考虑，能够保证正确性前提下，做好线程并发的控制，才是合格的业务代码。

Spring 和 ORM等框架
Spring以及MyBatis等ORM框架本质都属于应用程序框架范畴，框架存在的意义就是提取应用程序中通用的流程和特性作为自己的骨架，能够将上游不同的业务逻辑以插件的形式嵌入到框架中，简化应用程序开发过程，整体快速构建出应用程序；Spring的两大杀器是IOC和AOP，IOC基于依赖反转的模式实现了对象容器，将以前繁琐的对象之间的依赖关系维护和生命周期的管理从应用程序中抽离出来，单独放到IOC中进行管理，应用程序既能够方便从容器中获取对象，也能利用依赖注入的方式自动获取到对象引用，将对象的构建，组装和具体的业务逻辑脱离开单独管理，业务代码的职责更加单一纯粹，一方面业务代码能够更加简洁，同时对象的管理也更加规范，这是Spring能够成为Java应用程序开发实施标准的一个重要原因，Spring提供的第二大杀器是AOP，基于面向切面的思想，为应用程序提供了一种几乎无侵入的业务逻辑增强方式，本质是装饰模式的一种应用，利用Java的二进制工具或者是类继承的方式为原先的类生成增强类，Spring框架通过拦截器接管增强类的方法调用，在调用前后对方法进行增强甚至是功能替换，是比较优雅的一种功能增强实现，对业务代码侵入比较小，大量的其他框架需要针对业务代码进行功能增强时候，也是借助了Spring的AOP特性进行。MyBatis等ORM框架本质上是实现了一种Java对象读写和数据库中数据的映射，简化的是对于数据源的读写，能够以相同的数据对象视图对不同的数据源进行读写，在Java业务逻辑和数据源之间构造了一层模型层；不论是Java语言还是其他语言，都会有各种不同功能的框架，本质目标都是作为一个基座，简化上游应用程序的开发，而不是直接解决业务问题，需要和具体的业务逻辑结合在一起共同形成完整的软件功能，作为开发者，需要认清框架的本质，学会使用框架本来就是基本要求，严格讲熟练使用框架不能算作技能，而是从事相关必知必会的基础，作为合格开发人员，从源头理解清楚自己使用的框架解决什么问题，解决什么痛点，底层实现原理是什么远比让自己成为一个API熟练工重要。

MySQL数据库和SQL
软件领域有一类数据天然需要进行关联以提供给特定的业务使用，关系型数据库就是一类基于关系代数的数据存储系统，能够让应用软件通过关系代数组装不同的数据访问视图，MySQL就是关系型数据库产品中的一种，对事务有良好的支持，在当下互联网环境中使用较为广泛，SQL是访问关系型数据库的一种DSL，关系型数据库产品内部需要对SQL的编译，执行提供支持；作为一款成熟的RDBMS产品，MySQL提供了读写分离，主从复制，高可用，集群模式等互联网场景下常用或者说是必备的特性，可以借助MyCat等中间件或者ShardingJDBC驱动等方式使用这些特性，开发者如果只把MySQL当成一个工具使用，是非常简单的，实际业务开发中，具体的业务逻辑少不了和数据库进行交互，合格的业务代码不仅要保证数据访问的正确性，除此之外很重要一点是要保证数据访问的高效性，低效的SQL或者是不合理的MySQL部署方式都会造成严重的后果，轻则导致业务缓慢，重则引起数据库服务宕机，作为合格的开发人员，需要理解清楚数据库底层的实现原理，才能避免在业务中引入低效的SQL，把一些数据读写的低级错误在编写代码的开发阶段就发现并解决掉，保障业务能高效正确地运转，而不是等到后期让不合理的数据库访问成为系统性能的瓶颈。

分库分表
分库分表是数据库向分布式架构演进中的产物，传统的单体数据库结构有很多痛点，存储数据的容量受到单节点内存储器大小的限制，所有读写压力集中在一个节点，数据吞吐量受单节点物理机性能约束，单体结构本身也没有高可用的保证，由于单体结构存在的痛点，演进出了当下的分布式数据库结构，将数据分布于多个独立物理节点，作为集群共同提供服务，提升了整体的数据容量，同时能够在多个节点进行读写压力的分担，分库分表就是分布式数据库架构下面拆分数据的一种比较惯用的方法，分库和分表都有垂直拆分和水平拆分两种方式，垂直分库是将一个数据库拆分为多个提供不同业务数据的数据库，专库专表，垂直分库对于业务有比较大的影响，原来使用一个库中的表进行了关系代数运算的表如果拆解后分到了不同的库中，原来相关的sql就不得不进行修改，原本能够在同一个库里面直接用sql进行的关系代数运算就不得不移动到业务层自己实现，虽然垂直分库能够分解读写的压力，但是却可能造成业务的改动，对于其产生的利弊需要根据实际情况进行权衡；水平分库是根据固定的切割原则，将原来库中每一张数据表中的记录进行横向切割，切割出的不同部分分配到不同的库中，如果能够设计好切割的原则，让各个表中原来进行关系代数时候相关的记录都分配到一个库中去，业务层的逻辑就几乎不需要改动，只需要在数据访问层做分库的适配，同时能够起到多节点分担压力的效果；水平分表和垂直分表的原理类似，只不过分割操作在表内部进行，垂直分表是按照业务切分字段，和垂直分库一样，会影响业务，原来在一个表中的字段可能因为分表会需要修改成多个表之间的操作；水平分表是按照既定规则横向切割表中的记录，不同的记录子集形成新的数据表，对于一张表数量超大的情况，水平分表能够让单表索引的层数减少，提升单表查询效率； 分库分表是数据量膨胀之后有时候不得不进行的操作，具体的分库分表的方式需要根据具体业务形态进行权衡利弊，综合考虑分库分表带来的速度和容量提升以及给业务带来的修改以及维护负担，选择合适的方案进行

RPC和微服务
RPC是一种调用远端过程或者是服务功能的方式，在本地调用端和远端服务之间添加一个承担代理角色的调用层，该调用层功能是将本地调动转换为和远端服务通信的协议数据，通过和远端服务端交互的协议将本地调用请求发送给远端的服务器端，收取到远端相应数据后再转换为本地能够识别的格式，将结果传递给调用端，一般会在本地提供同步和异步掉用两种不同的方式，对于原先使用本地服务，而后改为远端服务的项目重构中，如果使用同步PRC进行重构，对业务侵入相对较小，业务层不需要修改，一般只需要在RPC这一层对远端服务进行适配，在本地提供和原来的服务一样的接口即可，对于比较耗时或者是对网络IO延迟敏感的业务，改造时候需要考虑将原先的同步方式修改为异步方式，对业务会产生一定侵入；RPC是多个服务之间进行功能调用和交互的方式之一，也是当代微服务架构的一项基础技术，微服务架构下，将具有独立功能的一组服务单独部署，单独工作，对外提供服务的同时需要和其他服务进行交互，RPC解决了服务和服务之间的基本通信交互问题，完整的微服务系统需要形成一个生态，不仅仅包含服务交互，还需要有服务治理，服务发现，服务注册，负载均衡，失效转移，高可用，限流，熔断，监控等等特性，大量的功能性的以及非功能性的特性融合在一起，才能形成一个完整的微服务生态

分布式缓存
缓存的应用几乎存在于计算机系统的各个领域，整个计算机存储系统的总体结构是金字塔形，上层的存储设备造价高速度快，下层的存储设备容量大但是速度慢，每一层存储介质都可以看做其下一层存储设备的缓存，例如内存可看作磁盘的缓存，Cache可看作内存的缓存，基于数据访问在时间上的局部性原理，当下访问的数据，大概率会在不久未来重复被访问，缓存系统基于此原理将读多写少的热数据在读取之后放置到缓存中，下一次读取时候直接从缓存获取，避免了每次读取都到底层低速系统中读取，不使用缓存一方面读写效率低下，另一方面所有读写都集中在一层，极可能形成整个系统中的性能瓶颈，缓存系统的分层结构本质上将读写压力分担到了不同的层次，读多写少的热数据的访问压力由上层高速缓存分担，写多读少的数据的读写压力由下层的低速缓存分担，由于采用分层结构，对于数据的更新必然存在各层之间数据同步的问题，将写多读少的数据放倒低层的缓存中可以减少同步的开销，牺牲了读写效率，保证了开销不会太大，反之读多写少的热数据放到高层的缓存中，虽然可能会多出一些同步开销，但是由于读操作偏多，因此高层缓存读写速度快的优势会带来相对更多的收益，数据依据自身的读写比例不同，分布在整个缓存系统的不同层次，总体上的读写效率是比只有单层低速设备要高的，且随着每层缓存速度的提升，其容量是按照金字塔结构递减的，总体的成本的增长不会非常高，缓存整体上讲是一种成本和效率上折中的存储方案；互联网环境中涉及大量的数据读写，数据库是存储系统逻辑上最底下的一层，也是最脆弱的一层，显然在高并发场景下将所有的请求全部打到数据库是不可能的，天然需要在整个软件系统中部署不同层次，不同功能的缓存，例如CDN是静态业务资源的缓存，业务中常用的Redis等缓存产品是一些读多写少的热数据缓存，缓存在整个软件系统中处处存在，呈现方式多种多样，目的都是减少其下一层的读写负担，提升整体的读写效率，每一层的缓存都为其下一层提供了分担压力，提升速度的服务，所以分布式环境中依然需要提供高可用，失效转移，分片扩容等特性，这些特性是分布式服务中必须有的特性，和分布式数据库，分布式消息队列等其他类型的服务所具备的分布式特性没有本质区别。作为开发人员，应该首先认识清楚缓存存在的意义，实际应用时候考虑清楚数据是否真的适合放到缓存中，综合考虑数据同步带来的开销和读写速度提升带来的收益，以及部署分布式环境的成本，结合数据本身特性和业务场景想清楚应该如何使用缓存，而不是无脑将数据往缓存中塞，滥用缓存

分布式消息队列
消息队列在概念上讲是一种通信方式，以先入先出的方式在发送者和接受者之间构造消息缓冲，发送者将消息发送给消息队列，由消息队列依照一定的路由规则将缓存下来的消息按序传递给接收者(具体实现形式有推模式和拉模式)，总体上是观察者模式的一种演绎，构造的是生产者消费者的模型，只有一个消息订阅者的场景就是点对点传输模式，多个订阅者场景就是Topic发布订阅模式，消息队列在软件系统各个层面都有其演绎形式，例如Linux内核提供的消息队列就是IPC的一种重要形式，互联网场景使用的消息队列一般泛指RabbitMQ这样的业务消息数据缓存系统，只是消息队列的其中一种使用方式，消息队列解决了复杂业务中服务间通信的一大痛点----“解耦”，传统的RPC调用中调用端和被调用端是有一定程度上耦合的，调用关系的拓扑是网状的，在业务比较复杂时候，调用关系比较混乱，会引入一定的维护开销，使用消息队列进行通信，由于消息中间件这一层的引入，数据的产出方和消费方是完全解耦的，互相不用进行感知，生产者，消费者，消息中间件共同组成的拓扑结构是星型的，逻辑结构简单，维护成本低，让生产者和消费者两端的业务逻辑都能相对简洁，实现异步通信也相对简单；消息队列解决的第二大痛点是“缓冲”，消息队列天然提供了对请求进行缓冲的功能，在消费者处理能力不足以处理大量请求场景下，能够让整个系统有能力将请求先缓存下来，等高峰期过了之后再处理，避免访问压力在整个系统中刚性传播，让系统有了削峰填谷的特性，所有请求是被消息队列比较均匀重新分配到了时间维度上的，避免了请求量在时间维度上分布不均造成的压力过大和饥饿问题；除此之外消息队列提供了消息持久化和保序的特性，为消息的可靠消费和多个消息组成的复合操作的原子性实现提供了可能，总体上讲，消息队列通信方式有很多良好的特性，现代互联网软件产业中有众多诸如RabbitMQ，RocketMQ，ActiveMQ等成熟的消息队列产品，各自有不同的功能优势，也在分布式环境下提供了高可用，失效转移，数据分片等特性；作为开发者，要透彻从源头理解消息队列存在的意义和解决的痛点，在复杂的模块间通信场景下合理使用消息队列