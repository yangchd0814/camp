1:串行GC(SerialGC)/ParNewGC
1.1:年轻代使用标记复制算法，老年代使用标记清除整理算法
1.2:SerialGC单线程串行执行，ParNewGC并行执行，都会触发STW
1.3:ParNewGC是针对串行GC做了改进，用并行的方式去回收年轻代的gc，可以看做是把串行gc的单线程换成了多线程

2:并行GC(ParallelGC和ParallelOldGC)
2.1:年轻代使用标记复制算法，老年代使用标记清除整理算法
2.2:并行进行垃圾回收，默认并行线程数为CPU核心数，可以通过参数ParallelGCThreads=N来指定回收线程数。
2.3:GC期间会触发STW
2.4:适用于多核服务器，主要目标是增加吞吐量
2.5:在GC期间，所有CPU内核都在并行清理垃圾，所以总暂停时间更短
2.6:在两次GC周期的间隔期，没有GC线程在运行，不会消耗任何系统资源

3:CMS
3.1:年轻代使用标记复制算法，老年代使用标记清除算法
3.2:目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过以下两种手段来达到这个目标
    3.2.1:不对老年代进行整理，而是使用空闲列表来管理内存空间的回收
    3.2.2:在标记清除阶段的大部分工作和应用线程一起并发执行，默认并发线程数为CPU核心数的1/4
3.3:cms回收垃圾时会经历6个阶段，其中有两个阶段需要STW
    3.3.1:初始标记，会STW。目标是标记所有的根对象，包括根对象直接引用的对象，以及被年轻代中所有存活对象引用的对象
    3.3.2:并发标记，遍历老年代，标记所有的存活对象，从第一个阶段找到的根对象开始算起。这个阶段与应用程序同时运行，不用暂停
    3.3.3:并发预处理，和应用程序并发执行。因为并发标记与程序并发运行，可能有一些引用关系已经发生了改变，如果有发生改变，JVM会通过Card的方式将发生改变的区域标记为脏区，这就是所谓的卡片标记
    3.3.4:最终标记，会STW。目标是完成老年代中所有存活对象的标记。因为之前的并发预处理阶段是并发执行的，有可能GC线程跟不上应用程序的修改速度，所以需要STW暂停来处理各种复杂的情况
    3.3.5:并发清除，与应用程序并发执行
    3.3.6:并发重置，与应用程序并发执行，删除不再使用的对象，并回收它们占用的内存空间
3.4:年轻代使用的是ParNewGC

4:G1
4.1:设计目标是将STW停顿的时间和分布，变成可预期且可配置的
4.2:堆不再分成年轻代和老年代，而是划分为多个可以存放对象的小块堆区域，可能一些会被定义成eden区，一些会被指定为S0,S1和old区。在逻辑上，所有的eden、S0、S1合起来就是年轻代，所有的old区合起来就是老年代
4.3:-XX:+MaxGCPauseMills参数可以设置预定G1每次执行GC操作的暂停时间，默认值200毫秒，G1会尽量保证控制在这个范围内
4.4:G1总共经历三个处理步骤
    4.4.1:年轻代模式转移暂停，G1 GC会通过前面一段时间的运行情况来不断的调整自己的回收策略和行为，以此来比较稳定地控制暂停时间。在应用程序刚启动时，G1还没有采集到足够的信息，这时候就处于初始的fully-young模式。当年轻代空间用满后，应用线程会被暂停，存活对象被拷贝到存活区。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区。
    4.4.2:并发标记，当堆内存的总体使用比例达到一定数值，就会触发并发标记。这个默认比例是45%，可以通过InitiatingHeapOccupancyPercent参数设置.总共有5个阶段
        4.4.2.1:初始标记，标记所有从GC根对象直接可达的对象
        4.4.2.2:Root区扫描，标记所有从根区域可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域
        4.4.2.3:并发标记，只遍历对象图，并在一个特殊的位图中标记能访问到的对象
        4.4.2.4:再次标记，会STW。会短暂地停止应用线程，停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标记开始未被标记的存活对象
        4.4.2.5:清理，为即将到来的转移阶段做准备，统计小堆块中所有存活的对象，并将小对快进行排序，以提升GC的效率，维护并发标记的内部状态。所有不包含存活对象的小堆块在此阶段都被回收了
    4.4.3:转移暂停：混合模式，并发标记完成之后，G1将执行一次混合收集，不只清理年轻代，还将一部分老年代区域也加入到回收集中。
4.5:某些情况下G1触发了full GC，会退化成使用SerialGC来完成垃圾的清理工作，有以下几种可能
    4.5.1:并发模式失败，G1启动标记周期，但在MIX GC之前，老年代就被填满，这时候G1会放弃标记周期。可以增加堆大小或者调整周期来解决
    4.5.2:晋升失败，没有足够的内存供存活对象或晋升对象使用。解决方法，增加-XX:G1ReservePercent选项值、减少-XX:InitiatingHeapOccupancyPercent提前启动标记周期、增加-XX:ConcGCThreads的值来增加并行标记线程的数目
    4.5.3:巨型对象分配失败，当巨型对象找不到合适的空间进行分配。解决办法，增加内存或者增大-XX:G1HeapRegionSize

5:ZGC
5.1:GC最大停顿时间不超过10ms
5.2:堆内存支持范围广，小至几百MB的堆空间，大至4TB的超大堆内存(JDK13升至16TB)
5.3:与G1相比，应用吞吐量下降不超过15%

6:ShenandoahGC
6.1:通过实现垃圾回收过程的并发处理，改善停顿时间，使用GC执行线程能够在业务处理线程运行过程中进行堆压缩、标记和整理，从而消除了绝大部分的暂停时间
6.2:GC的暂停时间与堆大小无关，无论是200MB还是200GB的堆内存，都可以保障具有很低的暂停时间